# c 语言编程规范

## 代码总体原则

1、清晰第一

清晰性是易于维护、易于重构的程序必需具备的特征。代码首先是给人读的，好的代码应当可以像文章一样发声朗诵出来。

目前软件维护期成本占整个生命周期成本的 40%~90%。根据业界经验，维护期变更代码的成本，小型系统是开发期的 5 倍，大型系统（100 万行代码以上）可以达到 100 倍。业界的调查指出，开发组平均大约一半的人力用于弥补过去的错误，而不是添加新的功能来帮助公司提高竞争力。

一般情况下，代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化。

2、简洁为美

简洁就是易于理解并且易于实现。代码越长越难以看懂，也就越容易在修改时引入错误。写的代码越多，意味着出错的地方越多，也就意味着代码的可靠性越低。因此，我们提倡大家通过编写简洁明了的代码来提升代码可靠性。

废弃的代码(没有被调用的函数和全局变量)要及时清除，重复代码应该尽可能提炼成函数。

3、选择合适的风格，与代码原有风格保持一致

产品所有人共同分享同一种风格所带来的好处，远远超出为了统一而付出的代价。在公司已有编码规范的指导下，审慎地编排代码以使代码尽可能清晰，是一项非常重要的技能。 如果重构/ / 修改其他风格的代码时，比较明智的做法是根据 现有 代码 的 现有风格继续编写代码，或者使用格式转换工具进行转换成公司内部风格。

2、头文件

对于 C 语言来说，头文件的设计体现了大部分的系统设计。 不合理的头文件布局是编译时间过长的根因，不合理的头文件实际上反映了不合理的设计。

1、头文件中适合放置接口的声明，不适合放置实现

头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。

要求：

    内部使用的函数（相当于类的私有方法）声明不应放在头文件中。
    内部使用的宏、枚举、结构定义不应放入头文件中。
    变量定义不应放在头文件中，应放在.c文件中。
    变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。 即使必须使用全局变量，也只应当在.c中定义全局变量，在.h中仅声明变量为全局的。

2、头文件应当职责单一，切忌依赖复杂

头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。很多现有代码中头文件过大，职责过多，再加上循环依赖的问题，可能导致为了在.c 中使用一个宏，而包含十几个头文件。

3、头文件应向稳定的方向包含

头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块。

就我们的产品来说，依赖的方向应该是： 产品依赖于平台，平台依赖于标准库。某产品线平台的代码中已经包含了产品的头文件，导致平台无法单独编译、发布和测试，是一个非常糟糕的反例。除了不稳定的模块依赖于稳定的模块外，更好的方式是两个模块共同依赖于接口，这样任何一个模块的内部实现更改都不需要重新编译另外一个模块。在这里，我们假设接口本身是最稳定的。

4、每一个 .c 文件应有一个同名 .h 文件，用于声明需要对外公开的接口

如果一个.c 文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如 main 函数所在的文件。

现有某些产品中，习惯一个.c 文件对应两个头文件，一个用于存放对外公开的接口，一个用于存放内部需要用到的定义、声明等，以控制.c 文件的代码行数。编者不提倡这种风格。这种风格的根源在于源文件过大，应首先考虑拆分.c 文件，使之不至于太大。另外，一旦把私有定义、声明放到独立的头文件中，就无法从技术上避免别人 include 之，难以保证这些定义最后真的只是私有的。

5、禁止头文件循环依赖

头文件循环依赖，指 a.h 包含 b.h，b.h 包含 c.h，c.h 包含 a.h 之类导致任何一个头文件修改，都导致所有包含了 a.h/b.h/c.h 的代码全部重新编译一遍。而如果是单向依赖，如 a.h 包含 b.h，b.h 包含 c.h，而 c.h 不包含任何头文件，则修改 a.h 不会导致包含了 b.h/c.h 的源代码重新编译。

6、 .c/.h 文件禁止包含用不到的头文件

很多系统中头文件包含关系复杂，开发人员为了省事起见，可能不会去一一钻研，直接包含一切想到的头文件，甚至有些产品干脆发布了一个 god.h，其中包含了所有头文件，然后发布给各个项目组使用，这种只图一时省事的做法，导致整个系统的编译时间进一步恶化，并对后来人的维护造成了巨大的麻烦。

7、 头文件应当自包含

简单的说，自包含就是任意一个头文件均可独立编译。如果一个文件包含某个头文件，还要包含另外一个头文件才能工作的话，就会增加交流障碍，给这个头文件的用户增添不必要的负担。

示例：如果 a.h 不是自包含的，需要包含 b.h 才能编译，会带来的危害：每个使用 a.h 头文件的.c 文件，为了让引入的 a.h 的内容编译通过，都要包含额外的头文件 b.h。额外的头文件 b.h 必须在 a.h 之前进行包含，这在包含顺序上产生了依赖。

注意：该规则需要与“.c/.h 文件禁止包含用不到的头文件”规则一起使用，不能为了让 a.h 自包含，而在 a.h 中包含不必要的头文件。a.h 要刚刚可以自包含，不能在 a.h 中多包含任何满足自包含之外的其他头文件。

8、总是编写内部 #include 保护符（ #define 保护）

多次包含一个头文件可以通过认真的设计来避免。如果不能做到这一点，就需要采取阻止头文件内容被包含多于一次的机制。通常的手段是为每个文件配置一个宏，当头文件第一次被包含时就定义这个宏，并在头文件被再次包含时使用它以排除文件内容。所有头文件都应当使用#define 防止头文件被多重包含，命名格式为 FILENAME_H，为了保证唯一性，更好的命名是 PROJECTNAME_PATH_FILENAME_H。

注：没有在宏最前面加上单下划线`_`，是因为一般以单下划线`_`和双下划线`__`开头的标识符为 ANSIC 等使用，在有些静态检查工具中，若全局可见的标识符以`_`开头会给出告警。

定义包含保护符时，应该遵守如下规则：

    保护符使用唯一名称；

    不要在受保护部分的前后放置代码或者注释。

正确示例：假定 VOS 工程的 timer 模块的 timer.h，其目录为 VOS/include/timer/timer.h,应按如下方式保护：

```C
#ifndef VOS_INCLUDE_TIMER_TIMER_H
#define VOS_INCLUDE_TIMER_TIMER_H
...
#endif

也可以使用如下简单方式保护:
#ifndef TIMER_H
#define TIMER_H
...
#endif
```

例外情况：头文件的版权声明部分以及头文件的整体注释部分（如阐述此头文件的开发背景、使用注意事项等）可以放在保护符(#ifndef XX_H)前面。

9、禁止在头文件中定义变量

在头文件中定义变量，将会由于头文件被其他.c 文件包含而导致变量重复定义。

10、只能通过包含头文件的方式使用其他 .c 提供的接口，禁止在.c 中通过 extern 的方式使用外部函数接口、变量

若 a.c 使用了 b.c 定义的 foo()函数，则应当在 b.h 中声明 extern int foo(int input)；并在 a.c 中通过#include <b.h>来使用 foo。禁止通过在 a.c 中直接写 extern int foo(int input);来使用 foo，后面这种写法容易在 foo 改变时可能导致声明和定义不一致。

11、禁止在 extern "C" 中包含头文件

在 extern "C"中包含头文件，会导致 extern "C"嵌套，Visual Studio 对 extern "C"嵌套层次有限制，嵌套层次太多会编译错误。
在 extern "C"中包含头文件，可能会导致被包含头文件的原有意图遭到破坏。

错误示例：

```C
extern "C"
{
    #include "xxx.h
    ...
}
```

正确示例：

```C
#include "xxx.h
extern "C"
{
    ...
}
```

12、一个模块通常包含多个 .c 文件，建议放在同一个目录下，目录名即为模块名。为方便外部使用者，建议每一个模块提供一个 .h ，文件名为目录名

需要注意的是，这个.h 并不是简单的包含所有内部的.h，它是为了模块使用者的方便，对外整体提供的模块接口。以 Google test（简称 GTest）为例，GTest 作为一个整体对外提供 C++单元测试框架，其 1.5 版本的 gtest 工程下有 6 个源文件和 12 个头文件。但是它对外只提供一个 gtest.h，只要包含 gtest.h 即可使用 GTest 提供的所有对外提供的功能，使用者不必关系 GTest 内部各个文件的关系，即使以后 GTest 的内部实现改变了，比如把一个源文件 c 拆成两个源文件，使用者也不必关心，甚至如果对外功能不变，连重新编译都不需要。对于有些模块，其内部功能相对松散，可能并不一定需要提供这个.h，而是直接提供各个子模块或者.c 的头文件。

比如产品普遍使用的 VOS，作为一个大模块，其内部有很多子模块，他们之间的关系相对比较松散，就不适合提供一个 vos.h。而 VOS 的子模块，如 Memory（仅作举例说明，与实际情况可能有所出入），其内部实现高度内聚，虽然其内部实现可能有多个.c 和.h，但是对外只需要提供一个 Memory.h 声明接口。

13、如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的 .h，文件名为子模块名

降低接口使用者的编写难度

14、头文件不要使用非习惯用法的扩展名，如 .inc

目前很多产品中使用了.inc 作为头文件扩展名，这不符合 c 语言的习惯用法。在使用.inc 作为头文件扩展名的产品，习惯上用于标识此头文件为私有头文件。但是从产品的实际代码来看，这一条并没有被遵守，一个.inc 文件被多个.c 包含比比皆是。

除此之外，使用.inc 还导致 source insight、Visual stduio 等 IDE 工具无法识别其为头文件，导致很多功能不可用，如“跳转到变量定义处”。虽然可以通过配置，强迫 IDE 识别.inc 为头文件，但是有些软件无法配置，如 Visual Assist 只能识别.h 而无法通过配置识别.inc。

15、同一产品统一包含头文件排列方式

常见的包含头文件排列方式：功能块排序、文件名升序、稳定度排序。

正确示例 1：以升序方式排列头文件可以避免头文件被重复包含：

```C
#include <a.h>
#include <b.h>
#include <c.h>
#include <c/a.h>
#include <d.h>
```

正确示例 2：以稳定度排序，建议将不稳定的头文件放在前面，如把产品的头文件放在平台的头文件前面：

```C
#include <product.h>
#include <platform.h>
```

相对来说，product.h 修改的较为频繁，如果有错误，不必编译 platform.h 就可以发现 product.h 的错误，可以部分减少编译时间。

## 函数

函数设计的精髓：编写整洁函数，同时把代码有效组织起来。

整洁函数要求：代码简单直接、不隐藏设计者的意图、用干净利落的抽象和直截了当的控制语句将函数有机组织起来。

代码的有效组织包括：逻辑层组织和物理层组织两个方面。逻辑层，主要是把不同功能的函数通过某种联系组织起来，主要关注模块间的接口，也就是模块的架构。物理层，无论使用什么样的目录或者名字空间等，需要把函数用一种标准的方法组织起来。例如：设计良好的目录结构、函数名字、文件组织等，这样可以方便查找。

1、一个函数仅完成一件功能

一个函数实现多个功能给开发、使用、维护都带来很大的困难。

将没有关联或者关联很弱的语句放到同一函数中，会导致函数职责不明确，难以理解，难以测试和改动。

2、重复代码应该尽可能提炼成函数

重复代码提炼成函数可以带来维护成本的降低。

重复代码是我司不良代码最典型的特征之一。在“代码能用就不改”的指导原则之下，大量的烟囱式设计及其实现充斥着各产品代码之中。新需求增加带来的代码拷贝和修改，随着时间的迁移，产品中堆砌着许多类似或者重复的代码。

项目组应当使用代码重复度检查工具，在持续集成环境中持续检查代码重复度指标变化趋势，并对新增重复代码及时重构。当一段代码重复两次时，即应考虑消除重复，当代码重复超过三次时，应当立刻着手消除重复。

3、避免函数过长，新增函数不超过 50 行 （非空非注释行）

过长的函数往往意味着函数功能不单一，过于复杂。

函数的有效代码行数，即 NBNC（非空非注释行）应当在[1，50]区间。

例外：某些实现算法的函数，由于算法的聚合性与功能的全面性，可能会超过 50 行。

延伸阅读材料： 业界普遍认为一个函数的代码行不要超过一个屏幕，避免来回翻页影响阅读；一般的代码度量工具建议都对此进行检查，例如 Logiscope 的函数度量："Number of Statement" （函数中的可执行语句数）建议不超过 20 行，QA C 建议一个函数中的所有行数（包括注释和空白行）不超过 50 行。

4、避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过 4 层

函数的代码块嵌套深度指的是函数中的代码控制块（例如：if、for、while、switch 等）之间互相包含的深度。每级嵌套都会增加阅读代码时的脑力消耗，因为需要在脑子里维护一个“栈”（比如，进入条件语句、进入循环„„）。应该做进一步的功能分解，从而避免使代码的阅读者一次记住太多的上下文。优秀代码参考值：[1, 4]。

5、 可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护

可重入函数是指可能被多个任务并发调用的函数。在多任务操作系统中，函数具有可重入性是多个任务可以共用此函数的必要条件。共享变量指的全局变量和 static 变量。编写 C 语言的可重入函数时，不应使用 static 局部变量，否则必须经过特殊处理，才能使函数具有可重入性。

示例：函数 square_exam 返回 g_exam 平方值。那么如下函数不具有可重入性。

```C
int g_exam;
unsigned int example( int para )
{
    unsigned int temp;
    g_exam = para; // **
    temp = square_exam ( );
    return temp;
}<
```

此函数若被多个线程调用的话，其结果可能是未知的，因为`**`语句刚执行完后，另外一个使用本函数的线程可能正好被激活，那么当新激活的线程执行到此函数时，将使 g_exam 赋于另一个不同的 para 值，所以当控制重新回到“temp =square_exam ( )”后，计算出的 temp 很可能不是预想中的结果。此函数应如下改进。

```C
int g_exam;
unsigned int example( int para )
{
    unsigned int temp;
    [申请信号量操作] // 若申请不到“信号量”,说明另外的进程正处于
    g_exam = para; //给g_exam赋值并计算其平方过程中,即正在使用此信
    temp = square_exam( ); // 本进程必须等待其释放信号后&#xff0c;才可继
    [释放信号量操作] // 续执行。其它线程必须等待本线程释放信号量后
    // 才能再使用本信号。
    return temp;
}
```

6、对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。缺省由调用者负责。

对于模块间接口函数的参数的合法性检查这一问题，往往有两个极端现象，即：要么是调用者和被调用者对参数均不作合法性检查，结果就遗漏了合法性检查这一必要的处理过程，造成问题隐患；要么就是调用者和被调用者均对参数进行合法性检查，这种情况虽不会造成问题，但产生了冗余代码，降低了效率。

7、对函数的错误返回码要全面处理

一个函数（标准库中的函数/第三方库函数/用户定义的函数）能够提供一些指示错误发生的方法。这可以通过使用错误标记、特殊的返回数据或者其他手段，不管什么时候函数提供了这样的机制，调用程序应该在函数返回时立刻检查错误指示。

8、设计高扇入，合理扇出（小于 7）的函数

扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。
扇出过大，表明函数过分复杂，需要控制和协调过多的下级函数；而扇出过小，例如：总是 1，表明函数的调用层次可能过多，这样不利于程序阅读和函数结构的分析，并且程序运行时会对系统资源如堆栈空间等造成压力。通常函数比较合理的扇出（调度函数除外）通常是 3~5。

扇出太大，一般是由于缺乏中间层次，可适当增加中间层次的函数。扇出太小，可把下级函数进一步分解多个函数，或合并到上级函数中。当然分解或合并函数时，不能改变要实现的功能，也不能违背函数间的独立性。扇入越大，表明使用此函数的上级函数越多，这样的函数使用效率高，但不能违背函数间的独立性而单纯地追求高扇入。公共模块中的函数及底层函数应该有较高的扇入。

较良好的软件结构通常是顶层函数的扇出较高，中层函数的扇出较少，而底层函数则扇入到公共模块中。

9、废弃代码（没有被调用的函数和变量) ) 要及时清除

程序中的废弃代码不仅占用额外的空间，而且还常常影响程序的功能与性能，很可能给程序的测试、维护等造成不必要的麻烦。

10、函数不变参数使用 const

不变的值更易于理解/跟踪和分析，把 const 作为默认选项，在编译时会对其进行检查，使代码更牢固/更安全。

正确示例：C99 标准 7.21.4.4 中 strncmp 的例子，不变参数声明为 const。

```C
int strncmp(const char *s1, const char *s2, register size_t n)
{
    register unsigned char u1, u2;
    while (n-- > 0)
    {
        u1 = (unsigned char) *s1++;
        u2 = (unsigned char) *s2++;
        if (u1 != u2)
        {
            return u1 - u2;
        }
        if (u1 == '\0')
        {
            return 0;
        }
    }
    return 0;
}
```

11、函数应避免使用全局变量、静态局部变量和 I/O 操作，不可避免的地方应集中使用

带有内部“存储器”的函数的功能可能是不可预测的，因为它的输出可能取决于内部存储器（如某标记）的状态。这样的函数既不易于理解又不利于测试和维护。在 C 语言中，函数的 static 局部变量是函数的内部存储器，有可能使函数的功能不可预测。

错误示例：如下函数，其返回值（即功能）是不可预测的。

<pre><code class="language-cpp">unsigned int integer_sum( unsigned int base )
{
    unsigned int index;
    static unsigned int sum &#61; 0;// 注意&#xff0c;是static类型的。
    // 若改为auto类型&#xff0c;则函数即变为可预测。
    for (index &#61; 1; index &lt;&#61; base; index&#43;&#43;)
    {
        sum &#43;&#61; index;
    }
    return sum;
}</code></pre>

12、检查函数所有非参数输入的有效性，如数据文件、公共变量等

函数的输入主要有两种：一种是参数输入；另一种是全局变量、数据文件的输入，即非参数输入。函数在使用输入参数之前，应进行有效性检查。

13、 函数的参数个数不超过 5 个

函数的参数过多，会使得该函数易于受外部（其他部分的代码）变化的影响，从而影响维护工作。函数的参数过多同时也会增大测试的工作量。

函数的参数个数不要超过 5 个，如果超过了建议拆分为不同函数。

14、除打印类函数外，不要使用可变长参函数。

可变长参函数的处理过程比较复杂容易引入错误，而且性能也比较低，使用过多的可变长参函数将导致函数的维护难度大大增加。

15、在源文件范围内声明和定义的所有函数，除非外部可见，否则应该增加 static 关键字

如果一个函数只是在同一文件中的其他地方调用，那么就用 static 声明。使用 static 确保只是在声明它的文件中是可见的，并且避免了和其他文件或库中的相同标识符发生混淆的可能性。

正确示例：建议定义一个 STATIC 宏，在调试阶段，将 STATIC 定义为 static，版本发布时，改为空，以便于后续的打热补丁等操作。

<pre><code class="language-cpp">#ifdef _DEBUG
#define STATIC static
#else
#define STATIC
#endif</code></pre>

## 标识符命名与定义

标识符的命名规则历来是一个敏感话题，典型的命名风格如 unix 风格、windows 风格等，从来无法达成共识。实际上，各种风格都有其优势也有其劣势，而且往往和个人的审美观有关。我们对标识符定义主要是为了让团队的代码看起来尽可能统一，有利于代码的后续阅读和修改，产品可以根据自己的实际需要指定命名风格，规范中不再做统一的规定。

1、标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解

尽可能给出描述性名称，不要节约空间，让别人很快理解你的代码更重要。

2、除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音

较短的单词可通过去掉“元音”形成缩写，较长的单词可取单词的头几个字母形成缩写，一些单词有大家公认的缩写，常用单词的缩写必须统一。协议中的单词的缩写与协议保持一致。对于某个系统使用的专用缩写应该在注视或者某处做统一说明。

```
argument 可缩写为 arg
buffer 可缩写为 buff
clock 可缩写为 clk
command 可缩写为 cmd
compare 可缩写为 cmp
configuration 可缩写为 cfg
device 可缩写为 dev
error 可缩写为 err
hexadecimal 可缩写为 hex
increment 可缩写为 inc
initialize 可缩写为 init
maximum 可缩写为 max
message 可缩写为 msg
minimum 可缩写为 min
parameter 可缩写为 para
previous 可缩写为 prev
register 可缩写为 reg
semaphore 可缩写为 sem
statistic 可缩写为 stat
synchronize 可缩写为 sync
temp 可缩写为 tmp
```

3、产品/项目组内部应保持统一的命名风格

Unix like 和 windows like 风格均有其拥趸，产品应根据自己的部署平台，选择其中一种，并在产品内部保持一致。

4、用正确的反义词组命名具有互斥意义的变量或相反动作的函数等

```
add/remove begin/end create/destroy
insert/delete first/last get/release
increment/decrement put/get add/delete
lock/unlock open/close min/max
old/new start/stop  next/previous
source/target show/hide  send/receive
source/destination copy/paste up/down
```

5、尽量避免名字中出现数字编号，除非逻辑上的确需要编号

6、标识符前不应添加模块、项目、产品、部门的名称作为前缀

很多已有代码中已经习惯在文件名中增加模块名，这种写法类似匈牙利命名法，导致文件名不可读，并且带来带来如下问题：

    第一眼看到的是模块名，而不是真正的文件功能，阻碍阅读；
    文件名太长；
    文件名和模块绑定，不利于维护和移植。若foo.c进行重构后，从a模块挪到b模块，若foo.c
    中有模块名，则需要将文件名从a_module_foo.c改为b_module_foo.c。

7、平台/ / 驱动等适配代码的标识符命名风格保持和平台

涉及到外购芯片以及配套的驱动，这部分的代码变动（包括为产品做适配的新增代码），应该保持原有的风格。

8、重构/修改部分代码时，应保持和原有代码的命名风格一致

根据源代码现有的风格继续编写代码，有利于保持总体一致。

9、文件命名统一采用小写字符

因为不同系统对文件名大小写处理会不同（如 MS 的 DOS、Windows 系统不区分大小写，但是 Linux 系统则区分），所以代码文件命名建议统一采用全小写字母命名。

10、全局变量应增加`g_` 前缀，静态变量应增加`s_`

首先，全局变量十分危险，通过前缀使得全局变量更加醒目，促使开发人员对这些变量的使用更加小心。

其次，从根本上说，应当尽量不使用全局变量，增加 `g_`和 `s_`前缀，会使得全局变量的名字显得很丑陋，从而促使开发人员尽量少使用全局变量。

11、禁止使用单字节命名变量，但 允许 定义 i 、j、k 作为局部循环变量

12、 不建议使用匈牙利命名法

匈牙利命名法是一种编程时的命名规范。基本原则是：变量名=属性+类型+对象描述。匈牙利命名法源于微软，然而却被很多人以讹传讹的使用。而现在即使是微软也不再推荐使用匈牙利命名法。历来对匈牙利命名法的一大诟病，就是导致了变量名难以阅读，这和本规范的指导思想也有冲突，所以本规范特意强调，变量命名不应采用匈牙利命名法，而应该想法使变量名为一个有意义的词或词组，方便代码的阅读。

变量命名需要说明的是变量的含义，而不是变量的类型。在变量命名前增加类型说明，反而降低了变量的可读性；更麻烦的问题是，如果修改了变量的类型定义，那么所有使用该变量的地方都需要修改。

13、使用名词或者形容词＋名词方式命名变量

14、函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构
正确示例：找到当前进程的当前目录：

```C
DWORD GetCurrentDirectory( DWORD BufferLength, LPTSTR Buffer );
```

15、函数指针除了前缀，其他按照函数的命名规则命名

16、对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线`_`的方式命名（枚举同样建议使用此方式定义）

```C
#define PI_ROUNDED 3.14
```

17、除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线`_`开头和结尾

一般来说，`_`开头、结尾的宏都是一些内部的定义，ISO/IEC 9899（俗称 C99）中有如下的描述（6.10.8 Predefined macro names）:

None of these macro names (这里上面是一些内部定义的宏的描述)，nor the identifier defined,shall be the subject of a #define or a #undef preprocessing directive.Any other predefined macro names shall begin with a leading underscore fol lowedby an uppercase letter ora second underscore.

## 变量

1、一个变量只有一个功能，不能把一个变量用作多种用途

一个变量只用来表示一个特定功能，不能把一个变量作多种用途，即同一变量取值不同时，其代表的意义也不同。

2、结构功能单一，不要设计面面俱到的数据结构

相关的一组信息才是构成一个结构体的基础，结构的定义应该可以明确的描述一个对象，而不是一组相关性不强的数据的集合。设计结构时应力争使结构代表一种现实事务的抽象，而不是同时代表多种。结构中的各元素应代表同一事务的不同侧面，而不应把描述没有关系或关系很弱的不同事务的元素放到同一结构中。

3、不用或者少用全局变量

单个文件内部可以使用 static 的全局变量，可以将其理解为类的私有成员变量。

全局变量应该是模块的私有数据，不能作用对外的接口使用，使用 static 类型定义，可以有效防止外部文件的非正常访问，建议定义一个 STATIC 宏，在调试阶段，将 STATIC 定义为 static，版本发布时，改为空，以便于后续的打补丁等操作。

4、防止局部变量与全局变量同名

尽管局部变量和全局变量的作用域不同而不会发生语法错误，但容易使人误解。

5、通讯过程中使用的结构，必须注意字节序

通讯报文中，字节序是一个重要的问题，我司设备使用的 CPU 类型复杂多样，大小端、32 位/64 位的处理器也都有，如果结构会在报文交互过程中使用，必须考虑字节序问题。由于位域在不同字节序下，表现看起来差别更大，所以更需要注意对于这种跨平台的交互，数据成员发送前，都应该进行主机序到网络序的转换；接收时，也必须进行网络序到主机序的转换。

6、严禁使用未经初始化的变量作为右值

在首次使用前初始化变量，初始化的地方离使用的地方越近越好。

7、构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象

降低全局变量耦合度。

8、使用面向接口编程思想，通过 API 访问数据：如果本模块的数据需要对外部模块开放 ，应提供接口函数来设置、获取，同时注意全局数据的访问互斥

避免直接暴露内部数据给外部模型使用，是防止模块间耦合最简单有效的方法。定义的接口应该有比较明确的意义，比如一个风扇管理功能模块，有自动和手动工作模式，那么设置、查询工作模块就可以定义接口为 SetFanWorkMode，GetFanWorkMode；查询转速就可以定义为 GetFanSpeed；风扇支持节能功能开关，可以定义 EnabletFanSavePower 等。

9、明确全局变量的初始化顺序，避免跨模块的初始化依赖

系统启动阶段，使用全局变量前，要考虑到该全局变量在什么时候初始化，使用全局变量和初始化全局变量，两者之间的时序关系，谁先谁后，一定要分析清楚，不然后果往往是低级而又灾难性的。

10、尽量减少没有必要的数据类型默认转换与强制转换

当进行数据类型强制转换时，其数据的意义、转换后的取值等都有可能发生变化，而这些细节若考虑不周，就很有可能留下隐患。

## 宏、常量

1、用宏定义表达式时，要使用完备的括号

因为宏只是简单的代码替换，不会像函数一样先将参数计算后，再传递。

2、将宏所定义的多条表达式放在大括号中

3、使用宏时，不允许参数发生变化
同时也建议即使函数调用，也不要在参数中做变量变化操作，因为可能引用的接口函数，在某个版本升级后，变成了一个兼容老版本所做的一个宏，结果可能不可预知。

4、不允许直接使用魔鬼数字

使用魔鬼数字的弊端：代码难以理解；如果一个有含义的数字多处使用，一旦需要修改这个数值，代价惨重。

使用明确的物理状态或物理意义的名称能增加信息，并能提供单一的维护点。

解决途径：对于局部使用的唯一含义的魔鬼数字，可以在代码周围增加说明注释，也可以定义局部 const 变量，变量命名自注释。对于广泛使用的数字，必须定义 const 全局变量/宏；同样变量/宏命名应是自注释的。0 作为一个特殊的数字，作为一般默认值使用没有歧义时，不用特别定义。

5、除非必要，应尽可能使用函数代替宏

宏对比函数，有一些明显的缺点：

    宏缺乏类型检查，不如函数调用检查严格；
    宏展开可能会产生意想不到的副作用，如#define SQUARE(a) (a) * (a)这样的定义，如果是SQUARE(i++)，就会导致i被加两次；如果是函数调用double square(double a) {return a * a;}则不会有此副作用；
    以宏形式写的代码难以调试难以打断点，不利于定位问题；
    宏如果调用的很多，会造成代码空间的浪费，不如函数空间效率高。

6、常量建议使用 const 定义代替宏

“尽量用编译器而不用预处理”，因为#define 经常被认为好象不是语言本身的一部分。看下面的语句：

```
#define ASPECT_RATIO 1.653
```

编译器会永远也看不到 ASPECT_RATIO 这个符号名，因为在源码进入编译器之前，它会被预处理程序去掉，于是 ASPECT_RATIO 不会加入到符号列表中。如果涉及到这个常量的代码在编译时报错，就会很令人费解，因为报错信息指的是 1.653，而不是 ASPECT_RATIO。如果 ASPECT_RATIO 不是在你自己写的头文件中定义的，你就会奇怪 1.653 是从哪里来的，甚至会花时间跟踪下去。这个问题也会出现在符号调试器中，因为同样地，你所写的符号名不会出现在符号列表中。
解决这个问题的方案很简单：不用预处理宏，定义一个常量：

```
const double ASPECT_RATIO = 1.653;
```

这种方法很有效，但有两个特殊情况要注意。首先，定义指针常量时会有点不同。因为常量定义一般是放在头文件中（许多源文件会包含它），除了指针所指的类型要定义成 const 外，重要的是指针也经常要定义成 const。例如，要在头文件中定义一个基于 char\*的字符串常量，你要写两次 const：

```
const char * const authorName = "Scott Meyers";
```

7、宏定义中尽量不使用 return 、 goto 、 continue 、 break 等改变程序流程的语句

如果在宏定义中使用这些改变流程的语句，很容易引起资源泄漏问题，使用者很难自己察觉。

## 表达式

1、表达式的值在标准所允许的任何运算次序下都应该是相同的

2、函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利

错误示例：如下代码不合理，仅用于说明当函数作为参数时，由于参数压栈次数不是代码可以控制的，可能造成未知的输出：

<pre><code class="language-cpp">int g_var;

int fun1()
{
    g_var &#43;&#61; 10;
    return g_var;
}

int fun2()
{
    g_var &#43;&#61; 100;
    return g_var;
}

int main(int argc, char *argv[], char *envp[])
{
    g_var &#61; 1;
    printf(&#34;func1: %d, func2: %d\n&#34;, fun1(), fun2());
    g_var &#61; 1;
    printf(&#34;func2: %d, func1: %d\n&#34;, fun2(), fun1());
}</code></pre>

上面的代码，使用断点调试起来也比较麻烦，阅读起来也不舒服，所以不要为了节约代码行，而写这种代码。

3、赋值语句不要写在 if 等语句中，或者作为函数的参数使用

因为 if 语句中，会根据条件依次判断，如果前一个条件已经可以判定整个条件，则后续条件语句不会再运行，所以可能导致期望的部分赋值没有得到运行。

错误示例：

<pre><code class="language-cpp">int main(int argc, char *argv[], char *envp[])
{
    int a &#61; 0;
    int b;
    if ((a &#61;&#61; 0) || ((b &#61; fun1()) &gt; 10))
    {
        printf(&#34;a: %d\n&#34;, a);
    }
    printf(&#34;b: %d\n&#34;, b);
}</code></pre>

作用函数参数来使用，参数的压栈顺序不同可能导致结果未知。

4、用括号明确表达式的操作顺序，避免过分依赖默认优先级

使用括号强调所使用的操作符，防止因默认的优先级与设计思想不符而导致程序出错；同时使得代码更为清晰可读，然而过多的括号会分散代码使其降低了可读性。

5、赋值操作符不能使用在产生布尔值的表达式上
示例：

<pre><code class="language-cpp">x &#61; y;
if (x !&#61; 0)
{
    foo ();
}</code></pre>

不能写成：

<pre><code class="language-cpp">if (( x &#61; y ) !&#61; 0)
{
    foo ();
}</code></pre>

或者更坏的：

<pre><code class="language-cpp">if (x &#61; y)
{
    foo ();
}</code></pre>

## 注释

1、优秀的代码可 以自我解释，不通过注释即可轻易读懂

优秀的代码不写注释也可轻易读懂，注释无法把糟糕的代码变好，需要很多注释来解释的代码往往存在坏味道，需要重构。

2、注释的内容要清楚、明了，含义准确，防止注释二义性

有歧义的注释反而会导致维护者更难看懂代码，正如带两块表反而不知道准确时间。

3、在代码的功能、意图层次上进行注释，即注释解释 代码难以直接表达的意图 ， 而不是重复描述代码

注释的目的是解释代码的目的、功能和采用的方法，提供代码以外的信息，帮助读者理解代码，防止没必要的重复注释信息。对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释。注释不是为了名词解释（what），而是说明用途（why）。

4、修改代码时，维护代码周边的所有注释，以保证注释与代码的一致性，不再有用的注释要删除

不要将无用的代码留在注释中，随时可以从源代码配置库中找回代码；即使只是想暂时排除代码，也要留个标注，不然可能会忘记处理它。

5、文件头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者姓名、工号、内容、功能说明、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明

```
/****************************************************************

Copyright: 1988-1999, Huawei Tech. Co., Ltd.

File name: 文件名

Description: 用于详细说明此程序文件完成的主要功能，与其他模块或函数的接口，输出值、取值范围、含义及参数间的控制、顺序、独立或依赖等关系

Author: 作者

Version: 版本

Date: 完成日期

History: 修改历史记录列表，每条修改记录应包括修改日期、修改者及修改内容简述。

*****************************************************************/
```

6、函数声明处注释描述函数功能、性能及用法，包括输入和输出参数、函数返回值、可重入的要求等；定义处详细描述函数功能和实现要点，如实现的简要步骤、实现的理由、 设计约束等

```
/*************************************************

Function: // 函数名称

Description: // 函数功能、性能等的描述

Calls: // 被本函数调用的函数清单

Called By: // 调用本函数的函数清单

Table Accessed: // 被访问的表（此项仅对于牵扯到数据库操作的程序）

Table Updated: // 被修改的表（此项仅对于牵扯到数据库操作的程序）

Input: // 输入参数说明，包括每个参数的作// 用、取值说明及参数间关系。

Output: // 对输出参数的说明。

Return: // 函数返回值的说明

Others: // 其它说明

*************************************************/
```

重要的、复杂的函数，提供外部使用的接口函数应编写详细的注释。

7、全局变量要有较详细的注释，包括对其功能、取值范围以及存取时注意事项等的说明

正确示例:

<pre><code class="language-cpp">/* The ErrorCode when SCCP translate */
/* Global Title failure, as follows */ /* 变量作用、含义*/
/* 0 &#xff0d;SUCCESS 1 &#xff0d;GT Table error */
/* 2 &#xff0d;GT error Others &#xff0d;no use */ /* 变量取值范围*/
/* only function SCCPTranslate() in */
/* this modual can modify it, and other */
/* module can visit it through call */
/* the function GetGTTransErrorCode() */ /* 使用方法*/
BYTE g_GTTranErrorCode;</code></pre>

8、注释应放在其代码上方相邻位置或右方，不可放在下面，如放于上方则需与其上面的代码用空行隔开，且与下方代码缩进相同

正确示例：

<pre><code class="language-cpp">/* active statistic task number */
#define MAX_ACT_TASK_NUMBER 1000
#define MAX_ACT_TASK_NUMBER 1000 /* active statistic task number */
可按如下形式说明枚举/数据/联合结构。
/* sccp interface with sccp user primitive message name */
enum SCCP_USER_PRIMITIVE
{
    N_UNITDATA_IND, /* sccp notify sccp user unit data come */
    N_NOTICE_IND, /* sccp notify user the No.7 network can not transmission this message */
    N_UNITDATA_REQ, /* sccp user&#39;s unit data transmission request*/
};</code></pre>

9、对于 switch 语句下的 case 语句，如果因为特殊情况需要处理完一个 case 后进入下一个 case 处理，必须在该 case 语句处理完、下一个 case 语句前加上明确的注释

这样比较清楚程序编写者的意图，有效防止无故遗漏 break 语句。

10、避免在注释中使用缩写，除非是业界通用或子系统内标准化的缩写

11、同一产品或项目组统一注释风格

12、避免在一行代码或表达式的中间插入注释

除非必要，不应在代码或表达中间插入注释，否则容易使代码可理解性变差

13、注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达，对于有外籍员工的，由产品确定注释语言

注释语言不统一，影响程序易读性和外观排版，出于对维护人员的考虑，建议使用中文。

14、文件头、函数头、全局常量变量、类型定义的注释格式采用工具可识别的格式

采用工具可识别的注释格式，例如 doxygen 格式，方便工具导出注释形成帮助文档。

## 排版与格式

1、程序块采用缩进风格编写， 每级缩进为 4 个空格

2、相对独立的程序块之间、变量说明之后必须加空行

错误示例：如下例子不符合规范。

<pre><code class="language-cpp">if (!valid_ni(ni))
{
    // program code
    ...
}
repssn_ind &#61; ssn_data[index].repssn_index;
repssn_ni &#61; ssn_data[index].ni;</code></pre>

正确示例：

<pre><code class="language-cpp">if (!valid_ni(ni))
{
    // program code
    ...
}

repssn_ind &#61; ssn_data[index].repssn_index;
repssn_ni &#61; ssn_data[index].ni;</code></pre>

3、一条语句不能过长，如不能拆分需要分行写。一行到底多少字符换行比较合适，产品可以自行确定

对于目前大多数的 PC 来说，132 比较合适（80/132 是 VTY 常见的行宽值）；对于新 PC 宽屏显示器较多的产品来说，可以设置更大的值。换行时有如下建议：

    换行时要增加一级缩进，使代码可读性更好；
    低优先级操作符处划分新行；换行时操作符应该也放下来，放在新行首；
    换行时建议一个完整的语句放在一行，不要根据字符数断行

4、多个短语句（包括赋值语句）不允许写在同一行内 ，即一行只写一条语句

5、if 、 for 、 do 、 while 、 case 、 switch 、 default 等语句独占一行

执行语句必须用缩进风格写，属于 if、for、do、while、case、switch、default 等下一个缩进级别；

一般写 if、for、do、while 等语句都会有成对出现的„{}‟，对此有如下建议可以参考：if、for、do、while 等语句后的执行语句建议增加成对的“{}”；如果 if/else 配套语句中有一个分支有“{}”，那么另一个分支即使一行代码也建议增加“{}”；添加“{”的位置可以在 if 等语句后，也可以独立占下一行；独立占下一行时，可以和 if 在一个缩进级别，也可以在下一个缩进级别；但是如果 if 语句很长，或者已经有换行，建议“{”使用独占一行的写法。

6、在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格 ； 进行非对等操作时，如果是关系密切的立即操作符（如－> > ），后不应加空格

采用这种松散方式编写代码的目的是使代码更加清晰。

在已经非常清晰的语句中没有必要再留空格，如括号内侧(即左括号后面和右括号前面)不需要加空格，多重括号间不必加空格，因为在 C 语言中括号已经是最清晰的标志了。在长语句中，如果需要加的空格非常多，那么应该保持整体清晰，而在局部不加空格。给操作符留空格时不要连续留两个以上空格。

正确示例：

1、逗号、分号只在后面加空格。

```C
int a, b, c;
```

2、比较操作符, 赋值操作符"="、 "+="，算术操作符"+"、"%"，逻辑操作符"&&"、"&"，位域操作符"<<"、"^"等双目操作符的前后加空格。

```C
if (current_time >= MAX_TIME_VALUE)
a = b + c;
a *= 2;
a = b ^ 2;
```

3、"!"、"~"、"++"、"--"、"&"（地址操作符）等单目操作符前后不加空格。

```C
*p = 'a';
flag = !is_empty;
p = &mem;
i++;
```

4、"->"、"."前后不加空格。

```C
p->id = pid;
```

5、if、for、while、switch 等与后面的括号间应加空格，使 if 等关键字更为突出、明显。

```C
if(a >= b && c >  d)
```

7、注释符（包括`/**/`、`//`）与注释内容之间要用一个空格进行分隔

8、源程序中关系较为紧密的代码应尽可能相邻

## 代码编辑编译

1、使用编译器的最高告警级别，理解所有的告警，通过修改代码而不是降低告警级别来消除所有告警

编译器是你的朋友，如果它发出某个告警，这经常说明你的代码中存在潜在的问题。

2、在产品软件（项目组）中，要统一编译开关、静态检查选项以及相应告警清除策略

如果必须禁用某个告警，应尽可能单独局部禁用，并且编写一个清晰的注释，说明为什么屏蔽。某些语句经编译/静态检查产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。

4、本地构建工具（如 PC-Lint）的配置应该和持续集成的一致

两者一致，避免经过本地构建的代码在持续集成上构建失败

5、 使用版本控制（配置管理）系统，及时签入通过本地构建的代码，确保签入的代码不会影响构建成功

及时签入代码降低集成难度。

6、要小心地使用编辑器提供的块拷贝功能编程

# 华为 C 语言编程规范

1 排版

1-1：程序块要采用缩进风格编写，缩进的空格数为 4 个。

说明：对于由开发工具自动生成的代码可以有不一致。

1-2：相对独立的程序块之间、变量说明之后必须加空行。如下例子不符合规范：

if (!valid_ni(ni))

{

... // program code

}

repssn_ind = ssn_data[index].repssn_index;

repssn_ni = ssn_data[index].ni;

应如下书写：

if (!valid_ni(ni))

{

... // program code

}

repssn_ind = ssn_data[index].repssn_index;

repssn_ni = ssn_data[index].ni;

1-3：较长的语句（>80 字符）要分成多行书写，长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要进行适当的缩进，使排版整齐，语句可读。示例：

perm_count_msg.head.len = NO7_TO_STAT_PERM_COUNT_LEN+STAT_SIZE_PER_FRAM \* sizeof( \_UL );

act_task_table[frame_id * STAT_TASK_CHECK_NUMBER +index].occupied= stat_poi[index].occupied;

act_task_table[taskno].duration_true_or_false=SYS_get_sccp_statistic_state( stat_item );

report_or_not_flag = ((taskno <MAX_ACT_TASK_NUMBER)&& (n7stat_stat_item_valid (stat_item))&&(act_task_table[taskno].result_data != 0));

1-4：不允许把多个短语句写在一行中，即一行只写一条语句。如下例子不符合规范：

rect.length= 0; rect.width = 0;

应如下书写：

rect.length= 0;

rect.width =0;

1-5：if、for、do、while、case、switch、default 等语句自占一行，且 if、for、do、while 等语句的执行语句部分无论多少都要加括号{}。如下例子不符合规范：

if (pUserCR== NULL) return;

应如下书写：

if (pUserCR== NULL)

{

return;

}

1-6：对齐只使用空格键，不使用 TAB 键。

说明：以免用不同的编辑器阅读程序时，因 TAB 键所设置的空格数目不同而造成程序布局不整齐，不要使用 BC 作为编辑器合版本，因为 BC 会自动将 8 个空格变为一个 TAB 键，因此使用 BC 合入的版本大多会将缩进变乱。

1-7：函数或过程的开始、结构的定义及循环、判断等语句中的代码都要采用缩进风格，case 语句下的情况处理语句也要遵从语句缩进要求。

1-8：程序块的分界符（如 C/C++语言的大括号‘{’和‘}’）应各独占一行并且位于同一列，同时与引用它们的语句左对齐。在函数体的开始、类的定义、结构的定义、枚举的定义以及 if、for、do、while、switch、case 语句中的程序都要采用如上的缩进方式。如下例子不符合规范：

for (...) {

... //program code

}

if (...)

{

... //program code

}

voidexample_fun( void )

{

... //program code

}

应如下书写：

for (...)

{

... //program code

}

if (...)

{

... //program code

}

voidexample_fun( void )

{

... //program code

}

1-9：一行程序以小于 80 字符为宜，不要写得过长。

2 注释

2-1：一般情况下，源程序有效注释量必须在 20％以上。

说明：注释的原则是有助于对程序的阅读理解，在该加的地方都加了，注释不宜太多也不能太少，注释语言必须准确、易懂、简洁。

2-2：文件头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、修改日志等。

示例：下面这段头文件的头注释比较标准，当然，并不局限于此格式，但上述信息建议要包含在内。

/********\*\*********\*\*********\*\*********\*********\*\*********\*\*********\*\*********

Copyright: 1988-1999, Huawei Tech. Co., Ltd.

File name: 文件名

Description: 用于详细说明此程序文件完成的主要功能，与其他模块或函数的接口，输出值、取值范围、含义及参数间的控制、顺序、独立或依赖等关系

Author: 作者

Version: 版本

Date: 完成日期

History: 修改历史记录列表，每条修改记录应包括修改日期、修改者及修改内容简述。

********\*\*********\*\*********\*\*********\*********\*\*********\*\*********\*\*********/

2-3：函数头部应进行注释，列出：函数的目的/功能、输入参数、输出参数、返回值、调用关系（函数、表）等。

示例：下面这段函数的注释比较标准，当然，并不局限于此格式，但上述信息建议要包含在内。

/****\*\*****\*\*\*\*****\*\*****\*****\*\*****\*\*\*\*****\*\*****

Function: // 函数名称

Description: // 函数功能、性能等的描述

Calls: // 被本函数调用的函数清单

Called By: // 调用本函数的函数清单

Table Accessed: // 被访问的表（此项仅对于牵扯到数据库操作的程序）

Table Updated: // 被修改的表（此项仅对于牵扯到数据库操作的程序）

Input: // 输入参数说明，包括每个参数的作// 用、取值说明及参数间关系。

Output: // 对输出参数的说明。

Return: // 函数返回值的说明

Others: // 其它说明

****\*\*****\*\*\*\*****\*\*****\*****\*\*****\*\*\*\*****\*\*****/

2-4：边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。

2-5：注释的内容要清楚、明了，含义准确，防止注释二义性。

说明：错误的注释不但无益反而有害。

2-6：注释应与其描述的代码相近，对代码的注释应放在其上方或右方（对单条语句的注释）相邻位置，不可放在下面，如放于上方则需与其上面的代码用空行隔开。如下例子不符合规范：

例 1：

/_ getreplicate sub system index and net indicator _/

repssn_ind =ssn_data[index].repssn_index;

repssn_ni =ssn_data[index].ni;

例 2：

repssn_ind =ssn_data[index].repssn_index;

repssn_ni =ssn_data[index].ni;

/_ getreplicate sub system index and net indicator _/

应如下书写：

/_ getreplicate sub system index and net indicator _/

repssn_ind =ssn_data[index].repssn_index;

repssn_ni =ssn_data[index].ni;

2-7：对于所有有物理含义的变量、常量，如果其命名不是充分自注释的，在声明时都必须加以注释，说明其物理含义。变量、常量、宏的注释应放在其上方相邻位置或右方。示例：

/_ activestatistic task number _/

#defineMAX_ACT_TASK_NUMBER 1000

#defineMAX*ACT_TASK_NUMBER 1000 /* active statistic task number \_/

2-8：数据结构声明(包括数组、结构、类、枚举等)，如果其命名不是充分自注释的，必须加以注释。对数据结构的注释应放在其上方相邻位置，不可放在下面；对结构中的每个域的注释放在此域的右方。

示例：可按如下形式说明枚举/数据/联合结构。

/_ sccpinterface with sccp user primitive message name _/

enumSCCP_USER_PRIMITIVE

{

N*UNITDATA_IND, /* sccp notify sccp user unit data come\_/

N*NOTICE_IND, /* sccp notify user the No.7 network cannot \_/

/_ transmission this message _/

N*UNITDATA_REQ, /* sccp user's unit data transmissionrequest\_/

};

2-9：全局变量要有较详细的注释，包括对其功能、取值范围、哪些函数或过程存取它以及存取时注意事项等的说明。示例：

/_ TheErrorCode when SCCP translate _/

/_ GlobalTitle failure, as follows _/ // 变量作用、含义

/_ 0 － SUCCESS 1 － GT Table error _/

/_ 2 － GT error Others － no use _/ // 变量取值范围

/_ onlyfunction SCCPTranslate() in _/

/_ thismodual can modify it, and other _/

/_ modulecan visit it through call _/

/_ thefunction GetGTTransErrorCode() _/ // 使用方法

BYTEg_GTTranErrorCode;

2-10：注释与所描述内容进行同样的缩排。

说明：可使程序排版整齐，并方便注释的阅读与理解。

示例：如下例子，排版不整齐，阅读稍感不方便。

voidexample_fun( void )

{

/_ code one comments _/

CodeBlock One

/_ code two comments _/

CodeBlock Two

}

应改为如下布局：

voidexample_fun( void )

{

/_ code one comments _/

CodeBlock One

/_ code two comments _/

CodeBlock Two

}

2-11：避免在一行代码或表达式的中间插入注释。

说明：除非必要，不应在代码或表达中间插入注释，否则容易使代码可理解性变差。

2-12：通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构，使代码成为自注释的。

说明：清晰准确的函数、变量等的命名，可增加代码可读性，并减少不必要的注释。

2-13：在代码的功能、意图层次上进行注释，提供有用、额外的信息。

说明：注释的目的是解释代码的目的、功能和采用的方法，提供代码以外的信息，帮助读者理解代码，防止没必要的重复注释信息。

示例：如下注释意义不大。

/_ ifreceive_flag is TRUE _/

if(receive_flag)

而如下的注释则给出了额外有用的信息。

/_ if mtpreceive a message from links _/

if(receive_flag)

2-14：在程序块的结束行右方加注释标记，以表明某程序块的结束。

说明：当代码段较长，特别是多重嵌套时，这样做可以使代码更清晰，更便于阅读。示例：参见如下例子。

if (...)

{

// programcode

while (index< MAX_INDEX)

{

// programcode

} /_ end ofwhile (index < MAX_INDEX) _/ // 指明该条 while 语句结束

} /_ end ofif (...)_/ // 指明是哪条 if 语句结束

2-15：注释格式尽量统一，建议使用“/_ …… _/”。

2-16：注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。

说明：注释语言不统一，影响程序易读性和外观排版，出于对维护人员的考虑，建议使用中文。

3 标识符命名

3-1：标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。

说明：较短的单词可通过去掉“元音”形成缩写；较长的单词可取单词的头几个字母形成缩写；一些单词有大家公认的缩写。示例：如下单词的缩写能够被大家基本认可。

temp 可缩写为 tmp ;

flag 可缩写为 flg ;

statistic 可缩写为 stat ;

increment 可缩写为 inc ;

message 可缩写为 msg ;

3-2：命名中若使用特殊约定或缩写，则要有注释说明。

说明：应该在源文件的开始之处，对文件中所使用的缩写或约定，特别是特殊的缩写，进行必要的注释说明。

3-3：自己特有的命名风格，要自始至终保持一致，不可来回变化。

说明：个人的命名风格，在符合所在项目组或产品组的命名规则的前提下，才可使用。（即命名规则中没有规定到的地方才可有个人命名风格）。

3-4：对于变量命名，禁止取单个字符（如 i、j、k...），建议除了要有具体含义外，还能表明其变量类型、数据类型等，但 i、j、k 作局部循环变量是允许的。

说明：变量，尤其是局部变量，如果用单个字符表示，很容易敲错（如 i 写成 j），而编译时又检查不出来，有可能为了这个小小的错误而花费大量的查错时间。

示例：下面所示的局部变量名的定义方法可以借鉴。

intliv_Width

其变量名解释如下：

l 局部变量（Local）（其它：g 全局变量（Global）...）

i 数据类型（Interger）

v 变量（Variable）（其它：c 常量（Const）...）

Width 变量含义

这样可以防止局部变量与全局变量重名。

3-5：命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用 UNIX 的全小写加下划线的风格或大小写混排的方式，不要使用大小写与下划线混排的方式，用作特殊标识如标识成员变量或全局变量的 m*和 g*，其后加上大小写混排的方式是允许的。

示例： Add_User 不允许，add_user、AddUser、m_AddUser 允许。

3-6：除非必要，不要用数字或较奇怪的字符来定义标识符。

示例：如下命名，使人产生疑惑。

#define*EXAMPLE_0_TEST*

#define*EXAMPLE_1_TEST*

voidset_sls00( BYTE sls );

应改为有意义的单词命名

#define*EXAMPLE_UNIT_TEST*

#define _EXAMPLE_ASSERT_TEST_

voidset_udt_msg_sls( BYTE sls );

3-7：在同一软件产品内，应规划好接口部分标识符（变量、结构、函数及常量）的命名，防止编译、链接时产生冲突。

说明：对接口部分的标识符应该有更严格限制，防止冲突。如可规定接口部分的变量与常量之前加上“模块”标识等。

3-8：用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。

说明：下面是一些在软件中常用的反义词组。

add / removebegin / end create / destroy

insert /delete first / last get / release

increment /decrement put / get

add / deletelock / unlock open / close

min / maxold / new start / stop

next /previous source / target show / hide

send /receive source / destination

cut / pasteup / down

示例：

int min_sum;

int max_sum;

intadd_user( BYTE \*user_name );

intdelete_user( BYTE \*user_name );

3-9：除了编译开关/头文件等特殊应用，应避免使用*EXAMPLE_TEST*之类以下划线开始和结尾的定义。

4 可读性

4-1：注意运算符的优先级，并用括号明确表达式的操作顺序，避免使用默认优先级。

说明：防止阅读程序时产生误解，防止因默认的优先级与设计思想不符而导致程序出错。

示例：下列语句中的表达式

word = (high<< 8) | low (1)

if ((a | b)&& (a & c)) (2)

if ((a | b)< (c & d)) (3)

如果书写为：

high<< 8 | low

a | b&& a & c

a | b < c& d

由于：

high<< 8 | low = ( high << 8) | low,

a | b&& a & c = (a | b) && (a & c)，

(1)(2)不会出错，但语句不易理解；a | b < c & d = a | （b < c） & d，(3)造成了判断条件出错。

4-2：避免使用不易理解的数字，用有意义的标识来替代。

涉及物理状态或者含有物理意义的常量，不应直接使用数字，必须用有意义的枚举或宏来代替。示例：如下的程序可读性差。

if(Trunk[index].trunk_state == 0)

{

Trunk[index].trunk_state= 1;

... //program code

}

应改为如下形式：

#defineTRUNK_IDLE 0

#defineTRUNK_BUSY 1

if(Trunk[index].trunk_state == TRUNK_IDLE)

{

Trunk[index].trunk_state= TRUNK_BUSY;

//program code

}

4-3：源程序中关系较为紧密的代码应尽可能相邻。

说明：便于程序阅读和查找。

示例：以下代码布局不太合理。

rect.length= 10;

char_poi =str;

rect.width =5;

若按如下形式书写，可能更清晰一些。

rect.length= 10;

rect.width =5; // 矩形的长与宽关系较密切，放在一起。

char_poi =str;

4-4：不要使用难懂的技巧性很高的语句，除非很有必要时。

说明：高技巧语句不等于高效率的程序，实际上程序的效率关键在于算法。

示例：如下表达式，考虑不周就可能出问题，也较难理解。

- stat_poi++ += 1;

- ++stat_poi += 1;

应分别改为如下。

\*stat_poi +=1;

stat_poi++;// 此二语句功能相当于“ \* stat_poi ++ += 1; ”

++ stat_poi;

_stat_poi +=1; // 此二语句功能相当于“ _ ++ stat_poi += 1; ”

5 变量、结构

5-1：去掉没必要的公共变量。

说明：公共变量是增大模块间耦合的原因之一，故应减少没必要的公共变量以降低模块间的耦合度。

5-2：仔细定义并明确公共变量的含义、作用、取值范围及公共变量间的关系。

说明：在对变量声明的同时，应对其含义、作用及取值范围进行注释说明，同时若有必要还应说明与其它变量的关系。

5-3：明确公共变量与操作此公共变量的函数或过程的关系，如访问、修改及创建等。

说明：明确过程操作变量的关系后，将有利于程序的进一步优化、单元测试、系统联调以及代码维护等。这种关系的说明可在注释或文档中描述。

示例：在源文件中，可按如下注释形式说明。

RELATIONSystem_Init Input_Rec Print_Rec Stat_Score Student Create Modify Access AccessScore Create Modify Access Access, Modify

注：RELATION 为操作关系；System_Init、Input_Rec、Print_Rec、Stat_Score 为四个不同的函数；Student、Score 为两个全局变量；Create 表示创建，Modify 表示修改，Access 表示访问。其中，函数 Input_Rec、Stat_Score 都可修改变量 Score，故此变量将引起函数间较大的耦合，并可能增加代码测试、维护的难度。

5-4：当向公共变量传递数据时，要十分小心，防止赋与不合理的值或越界等现象发生。

说明：对公共变量赋值时，若有必要应进行合法性检查，以提高代码的可靠性、稳定性。

5-5：防止局部变量与公共变量同名。

说明：若使用了较好的命名规则，那么此问题可自动消除。

5-6：严禁使用未经初始化的变量作为右值。

说明：特别是在 C/C++中引用未经赋值的指针，经常会引起系统崩溃。

5-7：结构的功能要单一，是针对一种事务的抽象。

说明：设计结构时应力争使结构代表一种现实事务的抽象，而不是同时代表多种。结构中的各元素应代表同一事务的不同侧面，而不应把描述没有关系或关系很弱的不同事务的元素放到同一结构中。

示例：如下结构不太清晰、合理。

typedefstruct STUDENT_STRU

{

unsignedchar name[8]; /_ student's name _/

unsignedchar age; /_ student's age _/

unsignedchar sex; /_ student's sex, as follows _/

/_ 0 -FEMALE; 1 - MALE _/

unsignedchar

teacher*name[8];/* the student teacher's name \_/

unisgnedchar

teacher*sex;/* his teacher sex \_/

} STUDENT;

若改为如下，可能更合理些：

typedefstruct TEACHER_STRU

{

unsignedchar name[8]; /_ teacher name _/

unisgnedchar sex; /_ teacher sex, as follows _/

/_ 0 -FEMALE; 1 - MALE _/

} TEACHER;

typedefstruct STUDENT_STRU

{

unsignedchar name[8]; /_ student's name _/

unsignedchar age; /_ student's age _/

unsignedchar sex; /_ student's sex, as follows _/

/_ 0 -FEMALE; 1 - MALE _/

unsigned intteacher*ind; /* his teacher index \_/

} STUDENT;

5-8：不要设计面面俱到、非常灵活的数据结构。

说明：面面俱到、灵活的数据结构反而容易引起误解和操作困难。

5-9：不同结构间的关系不要过于复杂。

说明：若两个结构间关系较复杂、密切，那么应合为一个结构。

示例：如下两个结构的构造不合理。

typedefstruct PERSON_ONE_STRU

{

unsignedchar name[8];

unsignedchar addr[40];

unsignedchar sex;

unsignedchar city[15];

}PERSON_ONE;

typedefstruct PERSON_TWO_STRU

{

unsignedchar name[8];

unsignedchar age;

unsignedchar tel;

}PERSON_TWO;

由于两个结构都是描述同一事物的，那么不如合成一个结构。

typedefstruct PERSON_STRU

{

unsignedchar name[8];

unsignedchar age;

unsignedchar sex;

unsignedchar addr[40];

unsignedchar city[15];

unsignedchar tel;

} PERSON;

5-10：结构中元素的个数应适中。若结构中元素个数过多可考虑依据某种原则把元素组成不同的子结构，以减少原结构中元素的个数。

说明：增加结构的可理解性、可操作性和可维护性。

示例：假如认为如上的\_PERSON 结构元素过多，那么可如下对之划分。

typedefstruct PERSON_BASE_INFO_STRU

{

unsignedchar name[8];

unsignedchar age;

unsignedchar sex;

}PERSON_BASE_INFO;

typedefstruct PERSON_ADDRESS_STRU

{

unsignedchar addr[40];

unsignedchar city[15];

unsignedchar tel;

}PERSON_ADDRESS;

typedefstruct PERSON_STRU

{

PERSON_BASE_INFOperson_base;

PERSON_ADDRESSperson_addr;

} PERSON;

5-11：仔细设计结构中元素的布局与排列顺序，使结构容易理解、节省占用空间，并减少引起误用现象。

说明：合理排列结构中元素顺序，可节省空间并增加可理解性。

示例：如下结构中的位域排列，将占较大空间，可读性也稍差。

typedefstruct EXAMPLE_STRU

{

unsigned intvalid: 1;

PERSONperson;

unsigned intset_flg: 1;

} EXAMPLE;

若改成如下形式，不仅可节省 1 字节空间，可读性也变好了。

typedefstruct EXAMPLE_STRU

{

unsigned intvalid: 1;

unsigned intset_flg: 1;

PERSONperson ;

} EXAMPLE;

5-12：编程时，要注意数据类型的强制转换。

说明：当进行数据类型强制转换时，其数据的意义、转换后的取值等都有可能发生变化，而这些细节若考虑不周，就很有可能留下隐患。

5-13：对编译系统默认的数据类型转换，也要有充分的认识。

示例：如下赋值，多数编译器不产生告警，但值的含义还是稍有变化。

char chr;

unsignedshort int exam;

chr = -1;

exam = chr;// 编译器不产生告警，此时 exam 为 0xFFFF。

5-14：尽量减少没有必要的数据类型默认转换与强制转换。

5-15：合理地设计数据并使用自定义数据类型，避免数据间进行不必要的类型转换。

5-16：对自定义数据类型进行恰当命名，使它成为自描述性的，以提高代码可读性。注意其命名方式在同一产品中的统一。

说明：使用自定义类型，可以弥补编程语言提供类型少、信息量不足的缺点，并能使程序清晰、简洁。

示例：可参考如下方式声明自定义数据类型。下面的声明可使数据类型的使用简洁、明了。

typedefunsigned char BYTE;

typedefunsigned short WORD;

typedefunsigned int DWORD;

下面的声明可使数据类型具有更丰富的含义。

typedeffloat DISTANCE;

typedeffloat SCORE;

6 函数、过程

6-1：对所调用函数的错误返回码要仔细、全面地处理。

6-2：明确函数功能，精确（而不是近似）地实现函数设计。

6-3：编写可重入函数时，应注意局部变量的使用（如编写 C/C++语言的可重入函数时，应使用 auto 即缺省态局部变量或寄存器变量）。

说明：编写 C/C++语言的可重入函数时，不应使用 static 局部变量，否则必须经过特殊处理，才能使函数具有可重入性。

6-4：编写可重入函数时，若使用全局变量，则应通过关中断、信号量（即 P、V 操作）等手段对其加以保护。

说明：若对所使用的全局变量不加以保护，则此函数就不具有可重入性，即当多个进程调用此函数时，很有可能使有关全局变量变为不可知状态。

示例：假设 Exam 是 int 型全局变量，函数 Squre_Exam 返回 Exam 平方值。那么如下函数不具有可重入性。

unsigned intexample( int para )

{

unsigned inttemp;

Exam = para;// （\*\*）

temp =Square_Exam( );

return temp;

}

此函数若被多个进程调用的话，其结果可能是未知的，因为当（\*\*）语句刚执行完后，另外一个使用本函数的进程可能正好被激活，那么当新激活的进程执行到此函数时，将使 Exam 赋与另一个不同的 para 值，所以当控制重新回到“temp = Square_Exam( )”后，计算出的 temp 很可能不是预想中的结果。此函数应如下改进。

unsigned intexample( int para )

{

unsigned inttemp;

[申请信号量操作] // 若申请不到“信号量”，说明另外的进程正处于 Exam = para; // 给 Exam 赋值并计算其平方过程中（即正在使用此 temp = Square_Exam( ); // 信号），本进程必须等待其释放信号后，才可继[释放信号量操作]

// 续执行。若申请到信号，则可继续执行，但其它进程必须等待本进程释放信号量后，才能再使用本信号。

return temp;

}

6-5：在同一项目组应明确规定对接口函数参数的合法性检查应由函数的调用者负责还是由接口函数本身负责，缺省是由函数调用者负责。

说明：对于模块间接口函数的参数的合法性检查这一问题，往往有两个极端现象，即：要么是调用者和被调用者对参数均不作合法性检查，结果就遗漏了合法性检查这一必要的处理过程，造成问题隐患；要么就是调用者和被调用者均对参数进行合法性检查，这种情况虽不会造成问题，但产生了冗余代码，降低了效率。

6-6：函数的规模尽量限制在 200 行以内。

说明：不包括注释和空格行。

6-7：一个函数仅完成一件功能，不要设计多用途面面俱到的函数。

说明：多功能集于一身的函数，很可能使函数的理解、测试、维护等变得困难。

6-8：函数的功能应该是可以预测的，也就是只要输入数据相同就应产生同样的输出。

说明：带有内部“存储器”的函数的功能可能是不可预测的，因为它的输出可能取决于内部存储器（如某标记）的状态。这样的函数既不易于理解又不利于测试和维护。在 C/C++语言中，函数的 static 局部变量是函数的内部存储器，有可能使函数的功能不可预测，然而，当某函数的返回值为指针类型时，则必须是 STATIC 的局部变量的地址作为返回值，若为 AUTO 类，则返回为错针。

示例：如下函数，其返回值（即功能）是不可预测的。

unsigned intinteger_sum( unsigned int base )

{

unsigned intindex;

staticunsigned int sum = 0; // 注意，是 static 类型的。

// 若改为 auto 类型，则函数即变为可预测。

for (index =1; index <= base; index++)

{

sum +=index;

}

return sum;

}

6-9：尽量不要编写依赖于其他函数内部实现的函数。

说明：此条为函数独立性的基本要求。由于目前大部分高级语言都是结构化的，所以通过具体语言的语法要求与编译器功能，基本就可以防止这种情况发生。但在汇编语言中，由于其灵活性，很可能使函数出现这种情况。

示例：如下是在 DOS 下 TASM 的汇编程序例子。过程 Print_Msg 的实现依赖于 Input_Msg 的具体实现，这种程序是非结构化的，难以维护、修改。

... // 程序代码

procPrint_Msg // 过程（函数）Print_Msg

... // 程序代码

jmp LABEL

... // 程序代码

endp

procInput_Msg // 过程（函数）Input_Msg

... // 程序代码

LABEL:

... // 程序代码

endp

6-10：检查函数所有参数输入的有效性。

6-11：检查函数所有非参数输入的有效性，如数据文件、公共变量等。

说明：函数的输入主要有两种：一种是参数输入；另一种是全局变量、数据文件的输入，即非参数输入。函数在使用输入之前，应进行必要的检查。

6-12：函数名应准确描述函数的功能。

6-13：使用动宾词组为执行某操作的函数命名。如果是 OOP 方法，可以只有动词（名词是对象本身）。

示例：参照如下方式命名函数。

voidprint_record( unsigned int rec_ind ) ;

intinput_record( void ) ;

unsignedchar get_current_color( void ) ;

6-14：避免使用无意义或含义不清的动词为函数命名。

说明：避免用含义不清的动词如 process、handle 等为函数命名，因为这些动词并没有说明要具体做什么。

6-15：函数的返回值要清楚、明了，让使用者不容易忽视错误情况。

说明：函数的每种出错返回值的意义要清晰、明了、准确，防止使用者误用、理解错误或忽视错误返回码。

6-16：除非必要，最好不要把与函数返回值类型不同的变量，以编译系统默认的转换方式或强制的转换方式作为返回值返回。

6-17：让函数在调用点显得易懂、容易理解。

6-18：在调用函数填写参数时，应尽量减少没有必要的默认数据类型转换或强制数据类型转换。

说明：因为数据类型转换或多或少存在危险。

6-19：避免函数中不必要语句，防止程序中的垃圾代码。

说明：程序中的垃圾代码不仅占用额外的空间，而且还常常影响程序的功能与性能，很可能给程序的测试、维护等造成不必要的麻烦。

6-20：防止把没有关联的语句放到一个函数中。

说明：防止函数或过程内出现随机内聚。随机内聚是指将没有关联或关联很弱的语句放到同一个函数或过程中。随机内聚给函数或过程的维护、测试及以后的升级等造成了不便，同时也使函数或过程的功能不明确。使用随机内聚函数，常常容易出现在一种应用场合需要改进此函数，而另一种应用场合又不允许这种改进，从而陷入困境。在编程时，经常遇到在不同函数中使用相同的代码，许多开发人员都愿把这些代码提出来，并构成一个新函数。若这些代码关联较大并且是完成一个功能的，那么这种构造是合理的，否则这种构造将产生随机内聚的函数。

示例：如下函数就是一种随机内聚。

voidInit_Var( void )

{

Rect.length = 0;

Rect.width = 0; /_ 初始化矩形的长与宽 _/

Point.x = 10;

Point.y = 10; /_ 初始化“点”的坐标 _/

}

矩形的长、宽与点的坐标基本没有任何关系，故以上函数是随机内聚。

应如下分为两个函数：

voidInit_Rect( void )

{

Rect.length = 0;

Rect.width = 0; /_ 初始化矩形的长与宽 _/

}

voidInit_Point( void )

{

Point.x = 10;

Point.y = 10; /_ 初始化“点”的坐标 _/

}

6-21：如果多段代码重复做同一件事情，那么在函数的划分上可能存在问题。

说明：若此段代码各语句之间有实质性关联并且是完成同一件功能的，那么可考虑把此段代码构造成一个新的函数。

6-22：功能不明确较小的函数，特别是仅有一个上级函数调用它时，应考虑把它合并到上级函数中，而不必单独存在。

说明：模块中函数划分的过多，一般会使函数间的接口变得复杂。所以过小的函数，特别是扇入很低的或功能不明确的函数，不值得单独存在。

6-23：设计高扇入、合理扇出（小于 7）的函数。

说明：扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。扇出过大，表明函数过分复杂，需要控制和协调过多的下级函数；而扇出过小，如总是 1，表明函数的调用层次可能过多，这样不利程序阅读和函数结构的分析，并且程序运行时会对系统资源如堆栈空间等造成压力。函数较合理的扇出（调度函数除外）通常是 3-5。扇出太大，一般是由于缺乏中间层次，可适当增加中间层次的函数。扇出太小，可把下级函数进一步分解多个函数，或合并到上级函数中。当然分解或合并函数时，不能改变要实现的功能，也不能违背函数间的独立性。

扇入越大，表明使用此函数的上级函数越多，这样的函数使用效率高，但不能违背函数间的独立性而单纯地追求高扇入。公共模块中的函数及底层函数应该有较高的扇入。较良好的软件结构通常是顶层函数的扇出较高，中层函数的扇出较少，而底层函数则扇入到公共模块中。

6-24：减少函数本身或函数间的递归调用。

说明：递归调用特别是函数间的递归调用（如 A->B->C->A），影响程序的可理解性；递归调用一般都占用较多的系统资源（如栈空间）；递归调用对程序的测试有一定影响。故除非为某些算法或功能的实现方便，应减少没必要的递归调用。

6-26：改进模块中函数的结构，降低函数间的耦合度，并提高函数的独立性以及代码可读性、效率和可维护性。优化函数结构时，要遵守以下原则：

（1）不能影响模块功能的实现。

（2）仔细考查模块或函数出错处理及模块的性能要求并进行完善。

（3）通过分解或合并函数来改进软件结构。

（4）考查函数的规模，过大的要进行分解。

（5）降低函数间接口的复杂度。

（6）不同层次的函数调用要有较合理的扇入、扇出。

（7）函数功能应可预测。

（8）提高函数内聚。（单一功能的函数内聚最高）

说明：对初步划分后的函数结构应进行改进、优化，使之更为合理。

6-27：在多任务操作系统的环境下编程，要注意函数可重入性的构造。

说明：可重入性是指函数可以被多个任务进程调用。在多任务操作系统中，函数是否具有可重入性是非常重要的，因为这是多个进程可以共用此函数的必要条件。另外，编译器是否提供可重入函数库，与它所服务的操作系统有关，只有操作系统是多任务时，编译器才有可能提供可重入函数库。如 DOS 下 BC 和 MSC 等就不具备可重入函数库，因为 DOS 是单用户单任务操作系统。

6-28：避免使用 BOOL 参数。

说明：原因有二，其一是 BOOL 参数值无意义，TURE/FALSE 的含义是非常模糊的，在调用时很难知道该参数到底传达的是什么意思；其二是 BOOL 参数值不利于扩充。还有 NULL 也是一个无意义的单词。

6-29：对于提供了返回值的函数，在引用时最好使用其返回值。

6-30：当一个过程（函数）中对较长变量（一般是结构的成员）有较多引用时，可以用一个意义相当的宏代替。

说明：这样可以增加编程效率和程序的可读性。

示例：在某过程中较多引用 TheReceiveBuffer[FirstSocket].byDataPtr，则可以通过以下宏定义来代替：

# definepSOCKDATA TheReceiveBuffer[FirstScoket].byDataPtr

7 程序效率

7-1：编程时要经常注意代码的效率。

说明：代码效率分为全局效率、局部效率、时间效率及空间效率。全局效率是站在整个系统的角度上的系统效率；局部效率是站在模块或函数角度上的效率；时间效率是程序处理输入任务所需的时间长短；空间效率是程序所需内存空间，如机器代码空间大小、数据空间大小、栈空间大小等。

7-2：在保证软件系统的正确性、稳定性、可读性及可测性的前提下，提高代码效率。

说明：不能一味地追求代码效率，而对软件的正确性、稳定性、可读性及可测性造成影响。

7-3：局部效率应为全局效率服务，不能因为提高局部效率而对全局效率造成影响。

7-4：通过对系统数据结构的划分与组织的改进，以及对程序算法的优化来提高空间效率。

说明：这种方式是解决软件空间效率的根本办法。

示例：如下记录学生学习成绩的结构不合理。

typedefunsigned char BYTE;

typedefunsigned short WORD;

typedefstruct STUDENT_SCORE_STRU

BYTEname[8];

BYTE age;

BYTE sex;

BYTE class;

BYTEsubject;

float score;

}STUDENT_SCORE;

因为每位学生都有多科学习成绩，故如上结构将占用较大空间。应如下改进（分为两个结构），总的存贮空间将变小，操作也变得更方便。

typedefstruct STUDENT_STRU

{

BYTEname[8];

BYTE age;

BYTE sex;

BYTE class;

} STUDENT;

typedefstruct STUDENT_SCORE_STRU

{

WORDstudent_index;

BYTEsubject;

float score;

}STUDENT_SCORE;

7-5：循环体内工作量最小化。

说明：应仔细考虑循环体内的语句是否可以放在循环体之外，使循环体内工作量最小，从而提高程序的时间效率。

示例：如下代码效率不高。

for (ind =0; ind < MAX_ADD_NUMBER; ind++)

{

sum += ind;

back*sum = sum; /* backup sum \_/

}

语句“back_sum = sum;”完全可以放在 for 语句之后，如下。

for (ind =0; ind < MAX_ADD_NUMBER; ind++)

{

sum+= ind;

}

back*sum =sum; /* backup sum \_/

7-6：仔细分析有关算法，并进行优化。仔细考查、分析系统及模块处理输入（如事务、消息等）的方式，并加以改进。

7-7：对模块中函数的划分及组织方式进行分析、优化，改进模块中函数的组织结构，提高程序效率。

说明：软件系统的效率主要与算法、处理任务方式、系统功能及函数结构有很大关系，仅在代码上下功夫一般不能解决根本问题。

7-8：编程时，要随时留心代码效率；优化代码时，要考虑周全。

7-9：不应花过多的时间拼命地提高调用不很频繁的函数代码效率。

说明：对代码优化可提高效率，但若考虑不周很有可能引起严重后果。

7-10：要仔细地构造或直接用汇编编写调用频繁或性能要求极高的函数。

说明：只有对编译系统产生机器码的方式以及硬件系统较为熟悉时，才可使用汇编嵌入方式。嵌入汇编可提高时间及空间效率，但也存在一定风险。

7-11：在保证程序质量的前提下，通过压缩代码量、去掉不必要代码以及减少不必要的局部和全局变量，来提高空间效率。

说明：这种方式对提高空间效率可起到一定作用，但往往不能解决根本问题。

7-12：在多重循环中，应将最忙的循环放在最内层。

说明：减少 CPU 切入循环层的次数。

示例：如下代码效率不高。

for (row =0; row < 100; row++)

{

for (col = 0; col < 5; col++)

{

sum += a[row][col];

}

}

可以改为如下方式，以提高效率。

for (col =0; col < 5; col++)

{

for (row = 0; row < 100; row++)

{

sum += a[row][col];

}

}

7-13：尽量减少循环嵌套层次。

7-14：避免循环体内含判断语句，应将循环语句置于判断语句的代码块之中。

说明：目的是减少判断次数。循环体中的判断语句是否可以移到循环体外，要视程序的具体情况而言，一般情况，与循环变量无关的判断语句可以移到循环体外，而有关的则不可以。

示例：如下代码效率稍低。

for (ind =0; ind < MAX_RECT_NUMBER; ind++)

{

if (data_type == RECT_AREA)

{

area_sum += rect_area[ind];

}

}

else

{

rect_length_sum += rect[ind].length;

rect_width_sum += rect[ind].width;

}

因为判断语句与循环变量无关，故可如下改进，以减少判断次数。

if(data_type == RECT_AREA)

{

for (ind = 0; ind < MAX_RECT_NUMBER; ind++)

{

area_sum += rect_area[ind];

}

}

else

{

for (ind = 0; ind < MAX_RECT_NUMBER; ind++)

{

rect_length_sum += rect[ind].length;

rect_width_sum += rect[ind].width;

}

}

7-15：尽量用乘法或其它方法代替除法，特别是浮点运算中的除法。

说明：浮点运算除法要占用较多 CPU 资源。

示例：如下表达式运算可能要占较多 CPU 资源。

#define PAI3.1416

radius =circle_length / (2 \* PAI);

应如下把浮点除法改为浮点乘法。

#definePAI_RECIPROCAL (1 / 3.1416 ) // 编译器编译时，将生成具体浮点数

radius =circle_length \* PAI_RECIPROCAL / 2;

7-16：不要一味追求紧凑的代码。

说明：因为紧凑的代码并不代表高效的机器码。

8 质量保证

8-1：在软件设计过程中构筑软件质量。

8-2：代码质量保证优先原则

（1）正确性，指程序要实现设计要求的功能。

（2）稳定性、安全性，指程序稳定、可靠、安全。

（3）可测试性，指程序要具有良好的可测试性。

（4）规范/可读性，指程序书写风格、命名规则等要符合规范。

（5）全局效率，指软件系统的整体效率。

（6）局部效率，指某个模块/子模块/函数的本身效率。

（7）个人表达方式/个人方便性，指个人编程习惯。

8-3：只引用属于自己的存贮空间。

说明：若模块封装的较好，那么一般不会发生非法引用他人的空间。

8-4：防止引用已经释放的内存空间。

说明：在实际编程过程中，稍不留心就会出现在一个模块中释放了某个内存块（如 C 语言指针），而另一模块在随后的某个时刻又使用了它。要防止这种情况发生。

8-5：过程/函数中分配的内存，在过程/函数退出之前要释放。

8-6：过程/函数中申请的（为打开文件而使用的）文件句柄，在过程/函数退出之前要关闭。

说明：分配的内存不释放以及文件句柄不关闭，是较常见的错误，而且稍不注意就有可能发生。这类错误往往会引起很严重后果，且难以定位。

示例：下函数在退出之前，没有把分配的内存释放。

typedefunsigned char BYTE;

intexample_fun( BYTE gt_len, BYTE \*gt_code )

{

BYTE \*gt_buf;

gt_buf = (BYTE \*) malloc (MAX_GT_LENGTH);

... //program code, include check gt_buf if or not NULL.

/_ global title length error _/

if (gt_len > MAX_GT_LENGTH)

{

return GT_LENGTH_ERROR; // 忘了释放 gt_buf

}

... // other program code

}

应改为如下。

intexample_fun( BYTE gt_len, BYTE \*gt_code )

{

BYTE \*gt_buf;

gt_buf = (BYTE \* ) malloc ( MAX_GT_LENGTH );

... // program code, include check gt_buf if or not NULL.

/_ global title length error _/

if (gt_len > MAX_GT_LENGTH)

{

free( gt_buf ); // 退出之前释放 gt_buf

return GT_LENGTH_ERROR;

}

... // other program code

}

8-7：防止内存操作越界。

说明：内存操作主要是指对数组、指针、内存地址等的操作。内存操作越界是软件系统主要错误之一，后果往往非常严重，所以当我们进行这些操作时一定要仔细小心。

示例：假设某软件系统最多可由 10 个用户同时使用，用户号为 1-10，那么如下程序存在问题。

#defineMAX_USR_NUM 10

unsignedchar usr_login_flg[MAX_USR_NUM]= "";

voidset_usr_login_flg( unsigned char usr_no )

{

if (!usr_login_flg[usr_no])

{

usr_login_flg[usr_no]= TRUE;

}

}

当 usr_no 为 10 时，将使用 usr_login_flg 越界。可采用如下方式解决。

voidset_usr_login_flg( unsigned char usr_no )

{

if (!usr_login_flg[usr_no - 1])

{

usr_login_flg[usr_no - 1]= TRUE;

}

}

8-8：认真处理程序所能遇到的各种出错情况。

8-9：系统运行之初，要初始化有关变量及运行环境，防止未经初始化的变量被引用。

8-10：系统运行之初，要对加载到系统中的数据进行一致性检查。

说明：使用不一致的数据，容易使系统进入混乱状态和不可知状态。

8-11：严禁随意更改其它模块或系统的有关设置和配置。

说明：编程时，不能随心所欲地更改不属于自己模块的有关设置如常量、数组的大小等。

8-12：不能随意改变与其它模块的接口。

8-13：充分了解系统的接口之后，再使用系统提供的功能。

示例：在 B 型机的各模块与操作系统的接口函数中，有一个要由各模块负责编写的初始化过程，此过程在软件系统加载完成后，由操作系统发送的初始化消息来调度。因此就涉及到初始化消息的类型与消息发送的顺序问题，特别是消息顺序，若没搞清楚就开始编程，很容易引起严重后果。以下示例引自 B 型曾出现过的实际代码，其中使用了 FID_FETCH_DATA 与 FID_INITIAL 初始化消息类型，注意 B 型机的系统是在 FID_FETCH_DATA 之前发送 FID_INITIAL 的。

MIDalarm_module_list[MAX_ALARM_MID];

int FARSYS_ALARM_proc( FID function_id, int handle )

{

\_UI i, j;

switch ( function_id )

{

... // program code

case FID_INITAIL:

for (i = 0; i < MAX_ALARM_MID; i++)

{

if (alarm_module_list[i]== BAM_MODULE // \*\*）

|| (alarm_module_list[i]== LOCAL_MODULE)

{

for (j = 0; j < ALARM_CLASS_SUM; j++)

{

FAR_MALLOC( ... );

}

}

}

... // program code

break;

case FID_FETCH_DATA:

... // program code

Get_Alarm_Module( ); // 初始化 alarm_module_list

break;

... // program code

}

}

由于 FID_INITIAL 是在 FID_FETCH_DATA 之前执行的，而初始化 alarm_module_list 是在 FID_FETCH_DATA 中进行的，故在 FID_INITIAL 中（**）处引用 alarm_module_list 变量时，它还没有被初始化。这是个严重错误。应如下改正：要么把 Get_Alarm_Module 函数放在 FID_INITIAL 中（**）之前；要么就必须考虑（\*\*）处的判断语句是否可以用（不使用 alarm_module_list 变量的）其它方式替代，或者是否可以取消此判断语句。

8-14：编程时，要防止差 1 错误。

说明：此类错误一般是由于把“<=”误写成“<”或“>=”误写成“>”等造成的，由此引起的后果，很多情况下是很严重的，所以编程时，一定要在这些地方小心。当编完程序后，应对这些操作符进行彻底检查。

8-15：要时刻注意易混淆的操作符。当编完程序后，应从头至尾检查一遍这些操作符，以防止拼写错误。

说明：形式相近的操作符最容易引起误用，如 C/C++中的“=”与“==”、“|”与“||”、“&”与“&&”等，若拼写错了，编译器不一定能够检查出来。

示例：如把“&”写成“&&”，或反之。

ret_flg =(pmsg->ret_flg & RETURN_MASK);

被写为：

ret_flg =(pmsg->ret_flg && RETURN_MASK);

rpt_flg =(VALID_TASK_NO( taskno ) && DATA_NOT_ZERO( stat_data ));

被写为：

rpt_flg =(VALID_TASK_NO( taskno ) & DATA_NOT_ZERO( stat_data ));

8-16：有可能的话，if 语句尽量加上 else 分支，对没有 else 分支的语句要小心对待；switch 语句必须有 default 分支。

8-17：Unix 下，多线程的中的子线程退出必需采用主动退出方式，即子线程应 return 出口。

8-18：不要滥用 goto 语句。

说明：goto 语句会破坏程序的结构性，所以除非确实需要，最好不使用 goto 语句。

8-19：精心地构造、划分子模块，并按“接口”部分及“内核”部分合理地组织子模块，以提高“内核”部分的可移植性和可重用性。

说明：对不同产品中的某个功能相同的模块，若能做到其内核部分完全或基本一致，那么无论对产品的测试、维护，还是对以后产品的升级都会有很大帮助。

8-20：精心构造算法，并对其性能、效率进行测试。

8-21：对较关键的算法最好使用其它算法来确认。

8-22：时刻注意表达式是否会上溢、下溢。

示例：如下程序将造成变量下溢。

unsignedchar size ;

while(size-- >= 0) // 将出现下溢

{

...// program code

}

当 size 等于 0 时，再减 1 不会小于 0，而是 0xFF，故程序是一个死循环。应如下修改。

char size;// 从 unsigned char 改为 char

while(size-- >= 0)

{

...// program code

}

8-23：使用变量时要注意其边界值的情况。

示例：如 C 语言中字符型变量，有效值范围为-128 到 127。故以下表达式的计算存在一定风险。

char chr =127;

int sum =200;

chr += 1; //127 为 chr 的边界值，再加 1 将使 chr 上溢到-128，而不是 128。

sum += chr;// 故 sum 的结果不是 328，而是 72。

若 chr 与 sum 为同一种类型，或表达式按如下方式书写，可能会好些。

sum = sum +chr + 1;

8-24：留心程序机器码大小（如指令空间大小、数据空间大小、堆栈空间大小等）是否超出系统有关限制。

8-25：为用户提供良好的接口界面，使用户能较充分地了解系统内部运行状态及有关系统出错情况。

8-26：系统应具有一定的容错能力，对一些错误事件（如用户误操作等）能进行自动补救。

8-27：对一些具有危险性的操作代码（如写硬盘、删数据等）要仔细考虑，防止对数据、硬件等的安全构成危害，以提高系统的安全性。

8-28：使用第三方提供的软件开发工具包或控件时，要注意以下几点：

（1）充分了解应用接口、使用环境及使用时注意事项。

（2）不能过分相信其正确性。

（3）除非必要，不要使用不熟悉的第三方工具包与控件。

说明：使用工具包与控件，可加快程序开发速度，节省时间，但使用之前一定对它有较充分的了解，同时第三方工具包与控件也有可能存在问题。

8-29：资源文件（多语言版本支持），如果资源是对语言敏感的，应让该资源与源代码文件脱离，具体方法有下面几种：使用单独的资源文件、DLL 文件或其它单独的描述文件（如数据库格式）

9 代码编辑、编译、审查

9-1：打开编译器的所有告警开关对程序进行编译。

9-2：在产品软件（项目组）中，要统一编译开关选项。

9-3：通过代码走读及审查方式对代码进行检查。

说明：代码走读主要是对程序的编程风格如注释、命名等以及编程时易出错的内容进行检查，可由开发人员自己或开发人员交叉的方式进行；代码审查主要是对程序实现的功能及程序的稳定性、安全性、可靠性等进行检查及评审，可通过自审、交叉审核或指定部门抽查等方式进行。

9-4：测试部测试产品之前，应对代码进行抽查及评审。

9-5：编写代码时要注意随时保存，并定期备份，防止由于断电、硬盘损坏等原因造成代码丢失。

9-6：同产品软件（项目组）内，最好使用相同的编辑器，并使用相同的设置选项。

说明：同一项目组最好采用相同的智能语言编辑器，如 Muiti Editor，Visual Editor 等，并设计、使用一套缩进宏及注释宏等，将缩进等问题交由编辑器处理。

9-7：合理地设计软件系统目录，方便开发人员使用。

说明：方便、合理的软件系统目录，可提高工作效率。目录构造的原则是方便有关源程序的存储、查询、编译、链接等工作，同时目录中还应具有工作目录----所有的编译、链接等工作应在此目录中进行，工具目录----有关文件编辑器、文件查找等工具可存放在此目录中。

9-8：某些语句经编译后产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。

说明：在 Borland C/C++中，可用“#pragma warn”来关掉或打开某些告警。

示例：

#pragma warn-rvl // 关闭告警

int examples_fun(void )

{

//程序，但无 return 语句。

}

#pragma warn+rvl // 打开告警

编译函数 examples_fun 时本应产生“函数应有返回值”告警，但由于关掉了此告警信息显示，所以编译时将不会产生此告警提示。

9-9：使用代码检查工具（如 C 语言用 PC-Lint）对源程序检查。

10 代码测试、维护

10-1：单元测试要求至少达到语句覆盖。

10-2：单元测试开始要跟踪每一条语句，并观察数据流及变量的变化。

10-3：清理、整理或优化后的代码要经过审查及测试。

10-4：代码版本升级要经过严格测试。

10-5：使用工具软件对代码版本进行维护。

10-6：正式版本上软件的任何修改都应有详细的文档记录。

10-7：发现错误立即修改，并且要记录下来。

10-8：关键的代码在汇编级跟踪。

10-9：仔细设计并分析测试用例，使测试用例覆盖尽可能多的情况，以提高测试用例的效率。

10-11：尽可能模拟出程序的各种出错情况，对出错处理代码进行充分的测试。

10-12：仔细测试代码处理数据、变量的边界情况。

10-13：保留测试信息，以便分析、总结经验及进行更充分的测试。

10-14：不应通过“试”来解决问题，应寻找问题的根本原因。

10-15：对自动消失的错误进行分析，搞清楚错误是如何消失的。

10-16：修改错误不仅要治表，更要治本。

10-17：测试时应设法使很少发生的事件经常发生。

10-18：明确模块或函数处理哪些事件，并使它们经常发生。

10-19：坚持在编码阶段就对代码进行彻底的单元测试，不要等以后的测试工作来发现问题。

10-20：去除代码运行的随机性（如去掉无用的数据、代码及尽可能防止并注意函数中的“内部寄存器”等），让函数运行的结果可预测，并使出现的错误可再现。

11 宏

11-1：用宏定义表达式时，要使用完备的括号。

示例：如下定义的宏都存在一定的风险。

#defineRECTANGLE_AREA( a, b ) a \* b

#defineRECTANGLE_AREA( a, b ) (a \* b)

#defineRECTANGLE_AREA( a, b ) (a) \* (b)

正确的定义应为：

#defineRECTANGLE_AREA( a, b ) ((a) \* (b))

11-2：将宏所定义的多条表达式放在大括号中。

示例：下面的语句只有宏的第一条表达式被执行。为了说明问题，for 语句的书写稍不符规范。

#defineINTI_RECT_VALUE( a, b )\

a = 0;\

b = 0;

for (index =0; index < RECT_TOTAL_NUM; index++)

INTI_RECT_VALUE(rect.a, rect.b );

正确的用法应为：

#defineINTI_RECT_VALUE( a, b )\

{\

a = 0;\

b = 0;\

}

for (index =0; index < RECT_TOTAL_NUM; index++)

{

INTI_RECT_VALUE(rect[index].a, rect[index].b );

}

11-3：使用宏时，不允许参数发生变化。

示例：如下用法可能导致错误。

#defineSQUARE( a ) ((a) \* (a))

int a = 5;

int b;

b = SQUARE(a++ ); // 结果：a = 7，即执行了两次增 1。

正确的用法是：

b = SQUARE(a );

a++; // 结果：a = 6，即只执行了一次增 1。
